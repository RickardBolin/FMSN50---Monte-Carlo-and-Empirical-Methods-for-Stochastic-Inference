clear
close all

N = 500; % Number of particles
steps = 10 + 1; 
dims = 10; % Dimensions
X = zeros(steps,dims,N);
w = zeros(steps,N);

% Set all starting weights to 1
w(1,:) = 1;

for k = 2:steps
   weight_distro = cumsum(w(k - 1,:)./sum(w(k - 1,:)));
   for i = 1:N
       
        % Resample
        parent_index = find((weight_distro > rand) == 1);
        parent_index = parent_index(1);
        X(1:k - 1,:,i) = X(1:k - 1,:,parent_index);        
       
        % Sample possible directions
        [oneHotDir, nfree] = g(X(1:k - 1,:,i));
        X(k,:,i) = X(k - 1,:,i) + oneHotDir;
        
        
        % Is it self avoiding?
        z = 1;
        if(length(unique(X(1:k,:,i),'row')) < k)
            z = 0;
        end
        
        % Set weight
        w(k,i) = (z/(1/(nfree))); 
   end 
   % Print progress
   if mod(k,5) == 0
       disp("Progress: Step " + k + "/" + (steps - 1)) 
   end
end

cn = cumprod(mean(w(2:end,:),2));
%%
mu2lim = nthroot(cn', 1:steps-1);
mu2 = mu2lim(end);
gamma2 = 43/32;
mu2nngamma2minus1 = (mu2.^(1:steps-1)).*((1:steps-1).^(gamma2-1));

A2 = cn./mu2nngamma2minus1';
%%
Y = log(cn) + log(1:steps)';
X_reg = [ones(steps,1) (1:steps)' log(1:steps)'];

beta = X_reg\Y;
expbeta = exp(beta)';

A_reg = expbeta(1);
mu_reg = expbeta(2);
gamma_reg = beta(3);

cn_reg = A_reg*(mu_reg.^(1:steps)).*((1:steps).^(gamma_reg - 1));

e = cn_reg' - cn;
